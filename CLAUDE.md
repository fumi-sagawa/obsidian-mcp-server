# CLAUDE.md

このファイルは、このリポジトリでコードを扱う際のClaude Code (claude.ai/code) への指針を提供します。

## 言語設定

このプロジェクトでは**日本語**を基本言語として使用します。コメント、ドキュメント、コミットメッセージなどは日本語で記述してください。

## プロジェクト概要

これは Model Context Protocol (MCP) サーバーのテンプレートプロジェクトです。Feature-Sliced Design (FSD) アーキテクチャに基づいた、拡張可能で保守しやすい構造を提供します。

## コマンド

### ビルド
```bash
npm run build              # TypeScriptをコンパイル
```

### 開発
```bash
npm install                # 依存関係のインストール
npm run dev                # 開発モード（ログレベル: debug）
npm run dev:trace          # トレースモード（全ログ出力）
npm run inspector          # MCP Inspector での実行
npm run inspector:debug    # MCP Inspector（デバッグモード）
```

### テスト
```bash
# 単体テスト
npm test                   # 全テストをカバレッジ付きで実行
npm run test:unit          # カバレッジなしで高速実行
npm run test:watch         # ファイル変更を監視して自動実行

# 手動テスト（MCPプロトコル経由）
npm run test:tools         # 全ツールの統合テスト
npm run test:tools:mock    # モックサーバーでのテスト
npm run test:tool          # 単一ツールのテスト（対話式）

# ヘルスチェック
npm run health-check       # スタンドアロンのヘルスチェック実行
```

## アーキテクチャ哲学 - Feature-Sliced Design (FSD)

このプロジェクトは、保守可能なアーキテクチャのためにFeature-Sliced Designの原則に従っています：

### ディレクトリ構造の原則
```
src/
├── app/              # アプリケーション層
├── features/         # 機能層（各機能は独立したディレクトリ）
├── entities/         # エンティティ層（ドメインモデル）
├── shared/           # 共有層（共通ユーティリティ、API）
└── index.ts          # エントリーポイント
```

各層の内部構造：
- **最小限の階層**: 不要なネストは避け、フラットな構造を保つ
- **明確な命名**: `lib`や`model`のような汎用的な名前は避ける
- **index.ts**: 各モジュールの公開APIとして使用

### 従うべきFSDの原則

1. **分離**: 各モジュールは独立している必要があります
   - 機能は互いに直接インポートしてはいけません
   - モジュール間の通信には明示的なパブリックAPIを使用します

2. **明示的な依存関係**: 下位層からのみインポートします
   - `app` → `features` → `entities` → `shared`
   - 同じ層や上位層からは決してインポートしません

3. **パブリックAPI**: 各モジュールは明確なパブリックインターフェースを公開します
   - パブリックAPIのエントリーポイントとして `index.ts` ファイルを作成します
   - 内部実装の詳細は非公開に保ちます

### リファクタリングのガイドライン

コードを変更する際は以下の構造を維持してください：

1. **`shared/` に配置するもの**:
   - 外部APIクライアント関数
   - 共通の型とインターフェース
   - エラーハンドリングユーティリティ
   - ロギングシステム
   - メトリクス収集
   - ヘルスチェック機能
   - 設定管理（config）
   - ミドルウェア

2. **`entities/` に配置するもの**:
   - ドメインモデルの型定義
   - ドメイン固有の定数や列挙型

3. **`features/` に配置するもの**:
   - 各機能の実装（ハンドラー、ビジネスロジック）
   - 機能固有のデータ変換・フォーマット処理
   - 入力値の検証スキーマ
   - 機能に閉じた型定義やユーティリティ

4. **`app/` に配置するもの**:
   - MCPサーバーの初期化
   - ツールの登録
   - トップレベルのエラーハンドリング

## テストアプローチ - テスト駆動開発（TDD）

このプロジェクトではテスト駆動開発（TDD）を採用しています：

### TDD開発フロー
1. **要件整理** - 実装する機能の要件を明確化
2. **テスト作成** - 要件に基づいてテストコードを先に作成
3. **実装** - テストが通るように本体コードを実装
4. **リファクタリング** - テストを維持しながらコードを改善

### TDD実践例
```typescript
// 1. 要件: 新しいツールを追加
// - 特定のパラメータを受け取って処理を実行
// - 必須パラメータが空の場合はエラー

// 2. テストを先に作成
describe('新機能ハンドラー', () => {
  it('有効なパラメータで正常に処理できる', async () => {
    const result = await handler({ param: '値' });
    assert(result.content[0].text.includes('処理結果'));
  });
  
  it('必須パラメータが空の場合はエラーを返す', async () => {
    await assert.rejects(
      () => handler({ param: '' }),
      { message: 'パラメータは必須です' }
    );
  });
});

// 3. テストが通るように実装
// 4. リファクタリング
```

### テスト作成のガイドライン
- テストの説明は日本語で記述（`it('正常なパラメータで処理が成功する')`）
- アサーションメッセージも日本語で記述
- 要件ごとにテストケースを作成
- エッジケースとエラーケースを必ず含める

### テスト構造
- 各featureの`tests/`ディレクトリにテストを配置
- ハンドラーのビジネスロジックに焦点を当てたテスト
- 依存性注入パターンでモックを実装

### テストカバレッジ
- 目標カバレッジ: 90%以上
- 重要なビジネスロジックは100%カバー
- エラーケースとエッジケースを網羅

### テストの実行
```bash
npm test              # カバレッジレポート付きで実行
npm run test:unit     # 高速実行（カバレッジなし）
npm run test:watch    # 開発中の自動テスト
```

## コードスタイル

- TypeScriptの厳密な型付けを使用する
- ES modulesを使用（相対インポートには`.js`拡張子を追加）
- Zodによるスキーマ検証を活用する
- エラーハンドリングは各層で適切に行う

## ロギングとデバッグ

### ロギング
- すべてのログは構造化ログ（JSON形式）で出力
- ログレベル: trace, debug, info, warn, error
- 環境変数 `LOG_LEVEL` で制御
- リクエストIDによるトレース追跡

### デバッグ
- `DEBUG_MODE=true` で詳細なデバッグ情報を出力
- `PRETTY_LOGS=true` で読みやすいログフォーマット
- MCP Inspector統合でインタラクティブなデバッグ

### 監視
- メトリクス収集（リクエスト数、エラー率、レスポンス時間）
- ヘルスチェック機能（メモリ使用量、外部API接続性）
- スロークエリの検出（`SLOW_OPERATION_THRESHOLD`で設定）

## 環境変数

| 変数名 | デフォルト値 | 説明 |
|--------|------------|------|
| LOG_LEVEL | info | ログレベル（trace/debug/info/warn/error） |
| DEBUG_MODE | false | デバッグモードの有効化 |
| PRETTY_LOGS | false | 読みやすいログフォーマット |
| LOG_TIMESTAMPS | true | ログにタイムスタンプを含める |
| SLOW_OPERATION_THRESHOLD | 1000 | スロークエリの閾値（ミリ秒） |
| API_TIMEOUT | 30000 | APIタイムアウト（ミリ秒） |
| API_RETRY_ATTEMPTS | 3 | APIリトライ回数 |

## プロジェクト管理

### プロジェクトフォルダ構造
```
project/
├── 要件定義.md          # プロジェクトの要件定義書
├── 参考文献/            # 外部仕様書やAPIドキュメントなど
└── tasks/               # タスク管理フォルダ
    ├── todo/            # 未着手のタスク
    ├── doing/           # 作業中のタスク
    └── done/            # 完了したタスク
```

### タスク管理フロー
1. **新規タスク作成**: `project/tasks/todo/` に新しいタスクファイルを作成
2. **作業開始**: タスクファイルを `doing/` フォルダに移動し、対応するブランチを作成
3. **作業完了**: タスクファイルを `done/` フォルダに移動

### タスクチケットテンプレート
```markdown
# タスク名: [わかりやすいタスク名]

## 概要
[このタスクで実現したいことの概要]

## 背景・目的
[なぜこのタスクが必要なのか]

## To-Be（完了条件）
- [ ] 実装完了条件1
- [ ] 実装完了条件2
- [ ] テストが全て通る
- [ ] ドキュメント更新完了

## 実装方針
[どのように実装するかの方針]

## 関連情報
- 関連Issue: #XX
- 参考資料: [リンク]

## 作業ログ
### YYYY-MM-DD HH:MM
- 作業内容の記録
- 発生した問題と解決方法
- 次回の作業予定

### YYYY-MM-DD HH:MM
- 進捗状況
- 実装した内容の詳細
- レビュー結果とフィードバック
```

### タスク管理のベストプラクティス
- タスクファイル名は `YYYYMMDD-タスク名.md` の形式で作成
- 作業ログは時系列で追記し、後から見返せるようにする
- ブランチ名はタスクファイル名と対応させる（例: `feature/20240524-add-new-tool`）
- 完了したタスクも削除せず、`done/` フォルダに保管して知識として蓄積